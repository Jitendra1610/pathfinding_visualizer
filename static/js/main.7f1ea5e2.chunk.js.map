{"version":3,"sources":["logo.svg","PathfindingVisualizer/Node/Node.jsx","algorithms/bfs.js","algorithms/dfs.js","algorithms/djikstra.js","MazeAlgorithms/dfsMaze.js","MazeAlgorithms/recursiveDivision.js","PathfindingVisualizer/PathfindingVisualizer.jsx","App.js","serviceWorker.js","index.js"],"names":["module","exports","Node","this","props","isFinish","isStart","isWall","isWeight","onMouseDown","onMouseUp","onMouseEnter","row","col","extraClassName","id","className","React","Component","Queue","arr","x","push","length","isEmpty","shift","getNodesInShortestPathOrder","finishNode","nodesInShortestPathOrder","currentNode","unshift","previousNode","dfs","grid","start","end","visitedOrder","dfsRecursive","node","isVisited","arr1","arr2","i","y","neighbour","QElement","element","priority","PriorityQueue","qElement","flag","splice","djikstra","nodes","getAllNodes","pq","distance","enqueue","temp","dequeue","value","Infinity","neighbor","edgeWeight","dfsMaze","start_x","start_y","start_node","visitedNodesInOrder","console","log","dfsMazeUtil","array","j","Math","floor","random","side_nodes_x1","side_nodes_y1","side_nodes_x2","side_nodes_y2","stack_child","k","new_x2","new_y2","new_x1","new_y1","childNode","pop","recursiveDivision","HEIGHT","WIDTH","node1","node2","recursiveDivisionUtil","startX","endX","startY","endY","orientation","getOrientation","wallX","getRandomInteger","skipY","wallY","skipX","min","max","START_ROW","START_COL","FINISH_ROW","FINISH_COL","stopAnimating","PathfindingVisualizer","state1","background","state","isMousePressed","isPickStart","isPickEnd","isBfs","isDfs","isPlaceWeight","isDjikstra","isAnimating","isDfsMaze","isMazeAnimating","getInitialGrid","setState","newGrid","getNewGridWithWeightToggled","getNewGridWithWallToggled","getNewGridWithEndToggled","getNewGridWithStartToggled","currGrid","slice","firstNodeInShortestPath","document","getElementById","animate","requestAnimationFrame","alert","startNode","animatingShortestPath","animateShortestPath","q","front","bfs","animateVisitedNodes","refreshBoardForPathfinding","refreshBoardForMaze","animateMaze","class","href","type","data-toggle","data-target","aria-controls","aria-expanded","aria-label","role","aria-haspopup","aria-labelledby","onClick","visualizeDFSMaze","visualizeRecursiveDivision","handleWeight","visualizeBFS","visualizeDFS","visualizeDJIKSTRA","clearBoard","style","paddingTop","map","rowIndex","key","nodeIndex","handleMouseDown","handleMouseEnter","handleMouseUp","currentRow","createNode","newNode","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.7f1ea5e2.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","import React from \"react\";\r\n\r\nimport \"./Node.css\";\r\n\r\nexport default class Node extends React.Component {\r\n  // constructor(props) {\r\n  //   super(props);\r\n  //   this.state = {};\r\n  // }\r\n\r\n  render() {\r\n    const {\r\n      isFinish,\r\n      isStart,\r\n      isWall,\r\n      isWeight,\r\n      onMouseDown,\r\n      onMouseUp,\r\n      onMouseEnter,\r\n      row,\r\n      col,\r\n    } = this.props;\r\n\r\n    const extraClassName = isFinish\r\n      ? \"node-finish\"\r\n      : isStart\r\n      ? \"node-start\"\r\n      : isWall\r\n      ? \"node-wall\"\r\n      : isWeight\r\n      ? \"node-weight\"\r\n      : \"\";\r\n\r\n    return (\r\n      <div\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${extraClassName}`}\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={() => onMouseUp()}\r\n      ></div>\r\n    );\r\n  }\r\n}\r\n","class Queue {\r\n    constructor() {\r\n      this.arr = [];\r\n    }\r\n  \r\n    enqueue(x) {\r\n      this.arr.push(x);\r\n    }\r\n  \r\n    isEmpty() {\r\n      if (this.arr.length == 0) return true;\r\n      return false;\r\n    }\r\n  \r\n    // printQueue(){\r\n    //     let str = \"\";\r\n    //     for(let i=0;i<this.arr.length;i++){\r\n    //         str+=this.arr[i]+\" \";\r\n    //     }\r\n    //     return str;\r\n    // }\r\n  \r\n    dequeue() {\r\n      if (this.isEmpty()) return \"Empty queue\";\r\n      return this.arr.shift();\r\n    }\r\n  \r\n    front() {\r\n      if (this.isEmpty()) {\r\n        return \"Empty queue\";\r\n      }\r\n      return this.arr[0];\r\n    }\r\n  }\r\n  \r\n  export function bfs(grid, start, end) {\r\n    const visitedOrder = [];\r\n    let q = new Queue();\r\n    q.enqueue(start);\r\n    visitedOrder.push(start);\r\n    start.isVisited = true;\r\n    const arr1 = [1, -1, 0, 0];\r\n    const arr2 = [0, 0, 1, -1];\r\n    while (!q.isEmpty()) {\r\n      let temp = q.front();\r\n      q.dequeue();\r\n      if (temp === end) break;\r\n      for (let i = 0; i < 4; i++) {\r\n        let row = temp.row + arr1[i];\r\n        let col = temp.col + arr2[i];\r\n        if (row < 0 || col < 0 || row >= grid.length || col >= grid[0].length)\r\n          continue;\r\n  \r\n        const neighbour = grid[row][col];\r\n        if (neighbour.isVisited || neighbour.isWall) continue;\r\n  \r\n        neighbour.isVisited = true;\r\n        q.enqueue(neighbour);\r\n        visitedOrder.push(neighbour);\r\n        neighbour.previousNode = temp;\r\n      }\r\n    }\r\n    return visitedOrder;\r\n  }\r\n  \r\n  export function getNodesInShortestPathOrder(finishNode) {\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode != null) {\r\n      nodesInShortestPathOrder.unshift(currentNode);\r\n      currentNode = currentNode.previousNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n  }\r\n  ","export function dfs(grid, start, end) {\r\n    const visitedOrder = [];\r\n    dfsRecursive(grid, start, end, visitedOrder);\r\n    return visitedOrder;\r\n  }\r\n  \r\n  function dfsRecursive(grid, node, end, visitedOrder) {\r\n    node.isVisited = true;\r\n    visitedOrder.push(node);\r\n    if (node === end) return true;\r\n  \r\n    const arr1 = [-1, 0, 1, 0];\r\n    const arr2 = [0, 1, 0, -1];\r\n    for (let i = 0; i < 4; i++) {\r\n      const x = node.row + arr1[i];\r\n      const y = node.col + arr2[i];\r\n      if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length) continue;\r\n      const neighbour = grid[x][y];\r\n      if (neighbour.isVisited || neighbour.isWall) continue;\r\n      neighbour.previousNode = node;\r\n      if (dfsRecursive(grid, neighbour, end, visitedOrder)) return true;\r\n    }\r\n    return false;\r\n  }\r\n  ","class QElement {\r\n    constructor(element, priority) {\r\n      this.element = element;\r\n      this.priority = priority;\r\n    }\r\n  }\r\n  class PriorityQueue {\r\n    constructor() {\r\n      this.arr = [];\r\n    }\r\n  \r\n    enqueue(element, priority) {\r\n      var qElement = new QElement(element, priority);\r\n      let flag = false;\r\n  \r\n      for (var i = 0; i < this.arr.length; i++) {\r\n        if (this.arr[i].priority > qElement.priority) {\r\n          flag = true;\r\n          this.arr.splice(i, 0, qElement);\r\n          break;\r\n        }\r\n      }\r\n  \r\n      if (!flag) {\r\n        this.arr.push(qElement);\r\n      }\r\n    }\r\n  \r\n    isEmpty() {\r\n      if (this.arr.length === 0) return true;\r\n      return false;\r\n    }\r\n  \r\n    dequeue() {\r\n      if (this.isEmpty()) return \"Underflow\";\r\n      return this.arr.shift();\r\n    }\r\n  \r\n    front() {\r\n      if (this.isEmpty()) return \"No Elements in Queue\";\r\n      return this.arr[0];\r\n    }\r\n  \r\n    rear() {\r\n      if (this.isEmpty()) return \"No elements in Queue\";\r\n      return this.arr[this.arr.length - 1];\r\n    }\r\n  }\r\n  \r\n  export function djikstra(grid, start, end) {\r\n    //let prev = [];\r\n    const nodes = getAllNodes(grid);\r\n    // nodes.forEach((node) => {\r\n    //   prev[node] = null;\r\n    // });\r\n    let pq = new PriorityQueue();\r\n  \r\n    start.distance = 0;\r\n    pq.enqueue(start, 0);\r\n    const visitedOrder = [];\r\n    while (!pq.isEmpty()) {\r\n      let temp = pq.dequeue();\r\n  \r\n      let value = temp.element;\r\n      let weight = temp.priority;\r\n  \r\n      if (value.distance === Infinity) break;\r\n  \r\n      visitedOrder.push(value);\r\n      value.isVisited = true;\r\n  \r\n      if (value === end) break;\r\n  \r\n      const arr1 = [1, 0, -1, 0];\r\n      const arr2 = [0, 1, 0, -1];\r\n  \r\n      for (let i = 0; i < 4; i++) {\r\n        let row = value.row + arr1[i];\r\n        let col = value.col + arr2[i];\r\n  \r\n        if (row < 0 || col < 0 || row >= grid.length || col >= grid[0].length)\r\n          continue;\r\n  \r\n        const neighbor = grid[row][col];\r\n        if (neighbor.isVisited === true || neighbor.isWall === true) continue;\r\n  \r\n        if (value.distance + 1 < neighbor.distance) {\r\n          let edgeWeight = 1;\r\n          if (neighbor.isWeight) edgeWeight = edgeWeight * 10;\r\n          neighbor.distance = value.distance + edgeWeight;\r\n          neighbor.previousNode = value;\r\n          //prev[neighbor] = value;\r\n          pq.enqueue(neighbor, neighbor.distance);\r\n        }\r\n      }\r\n    }\r\n    return visitedOrder;\r\n  }\r\n  \r\n  function getAllNodes(grid) {\r\n    const nodes = [];\r\n    for (const row of grid) {\r\n      for (const node of row) {\r\n        nodes.push(node);\r\n      }\r\n    }\r\n    return nodes;\r\n  }\r\n  ","export function dfsMaze(grid, start_x, start_y) {\r\n    const start_node = grid[start_x][start_y];\r\n    start_node.isVisited = true;\r\n    start_node.isWall = true;\r\n    const visitedNodesInOrder = [start_node];\r\n    console.log(start_x, start_y);\r\n    dfsMazeUtil(grid, start_x, start_y, visitedNodesInOrder);\r\n    return visitedNodesInOrder;\r\n  }\r\n  \r\n  function dfsMazeUtil(grid, x, y, visitedNodesInOrder) {\r\n    const node = grid[x][y];\r\n    // Shuffling indexes\r\n    const array = [0, 1, 2, 3];\r\n    for (let i = array.length - 1; i > 0; i--) {\r\n      const j = Math.floor(Math.random() * (i + 1));\r\n      [array[i], array[j]] = [array[j], array[i]];\r\n    }\r\n    console.log(array);\r\n    const side_nodes_x1 = [0, 0, 1, -1];\r\n    const side_nodes_y1 = [1, -1, 0, 0];\r\n    const side_nodes_x2 = [0, 0, 2, -2];\r\n    const side_nodes_y2 = [2, -2, 0, 0];\r\n    const stack_child = [];\r\n    for (let k = 0; k <= 3; ++k) {\r\n      const i = array[k];\r\n      const { col, row } = node;\r\n      const new_x2 = row + side_nodes_x2[i];\r\n      const new_y2 = col + side_nodes_y2[i];\r\n      if (\r\n        !(\r\n          new_x2 >= 0 &&\r\n          new_y2 >= 0 &&\r\n          new_x2 < grid.length &&\r\n          new_y2 < grid[0].length\r\n        )\r\n      )\r\n        continue;\r\n      const neighbor = grid[new_x2][new_y2];\r\n      if (neighbor.isVisited === true || neighbor.isWall === true) continue;\r\n      const new_x1 = row + side_nodes_x1[i];\r\n      const new_y1 = col + side_nodes_y1[i];\r\n      if (\r\n        new_x1 >= 0 &&\r\n        new_y1 >= 0 &&\r\n        new_x1 < grid.length &&\r\n        new_y1 < grid[0].length\r\n      ) {\r\n        grid[new_x1][new_y1].isWall = true;\r\n        grid[new_x1][new_y1].isVisited = true;\r\n        visitedNodesInOrder.push(grid[new_x1][new_y1]);\r\n      }\r\n      stack_child.push({ x: new_x2, y: new_y2 });\r\n      const childNode = grid[new_x2][new_y2];\r\n      childNode.isVisited = true;\r\n      childNode.isWall = true;\r\n      visitedNodesInOrder.push(grid[new_x2][new_y2]);\r\n      // dfsMazeUtil(grid, new_x2, new_y2, visitedNodesInOrder);\r\n    }\r\n    // console.log(stack_child)\r\n    while (stack_child.length !== 0) {\r\n      const node = stack_child.pop();\r\n      dfsMazeUtil(grid, node[\"x\"], node[\"y\"], visitedNodesInOrder);\r\n    }\r\n  }\r\n  ","export function recursiveDivision(grid) {\r\n    const visitedNodesInOrder = [];\r\n    const HEIGHT = grid.length;\r\n    const WIDTH = grid[0].length;\r\n    for (let x = 0; x < HEIGHT; ++x) {\r\n      const node1 = grid[x][0],\r\n        node2 = grid[x][WIDTH - 1];\r\n      node1.isWall = true;\r\n      node2.isWall = true;\r\n      visitedNodesInOrder.push(node1);\r\n      visitedNodesInOrder.push(node2);\r\n    }\r\n    for (let y = 0; y < WIDTH; ++y) {\r\n      const node1 = grid[0][y],\r\n        node2 = grid[HEIGHT - 1][y];\r\n      node1.isWall = true;\r\n      node2.isWall = true;\r\n      visitedNodesInOrder.push(node1);\r\n      visitedNodesInOrder.push(node2);\r\n    }\r\n    recursiveDivisionUtil(grid, visitedNodesInOrder, 1, HEIGHT - 2, 1, WIDTH - 2);\r\n    return visitedNodesInOrder;\r\n  }\r\n  \r\n  /*\r\n  params = (x, y) are the top-left coordinates of the grid section.\r\n          (HEIGHT, WIDTH) are the size\r\n  function = basically it chooses draws either horizontal or vertical wall line and skips one node to leave a passage\r\n  and calls the function on both sides of section.\r\n  if HEIGHT > WIDTH use horizontal\r\n  else if WIDTH > HEIGHT use vertical\r\n  else take random one\r\n  */\r\n  function recursiveDivisionUtil(\r\n    grid,\r\n    visitedNodesInOrder,\r\n    startX,\r\n    endX,\r\n    startY,\r\n    endY\r\n  ) {\r\n    const HEIGHT = endX - startX + 1;\r\n    const WIDTH = endY - startY + 1;\r\n    // Base Case\r\n    if (HEIGHT <= 2 || WIDTH <= 2) return;\r\n    // Corner Case\r\n    if (\r\n      startX < 0 ||\r\n      startY < 0 ||\r\n      endX >= grid.length ||\r\n      endY >= grid[0].length ||\r\n      startX > endX ||\r\n      startY > endY\r\n    )\r\n      return;\r\n    // Choose orientation\r\n    const orientation = getOrientation(HEIGHT, WIDTH);\r\n    // Generate the wall and divide the grid and call recursively\r\n    if (orientation === \"Horizontal\") {\r\n      // console.log(\"Horizontal \", startX, startY, endX, endY);\r\n      const wallX = getRandomInteger(startX + 1, endX - 1);\r\n      const skipY = getRandomInteger(startY, endY);\r\n      for (let wallY = startY; wallY <= endY; ++wallY) {\r\n        if (wallY === skipY) continue;\r\n        const node = grid[wallX][wallY];\r\n        node.isWall = true;\r\n        visitedNodesInOrder.push(node);\r\n      }\r\n      recursiveDivisionUtil(\r\n        grid,\r\n        visitedNodesInOrder,\r\n        startX,\r\n        wallX - 1,\r\n        startY,\r\n        endY\r\n      ); //Above\r\n      recursiveDivisionUtil(\r\n        grid,\r\n        visitedNodesInOrder,\r\n        wallX + 1,\r\n        endX,\r\n        startY,\r\n        endY\r\n      ); //Below\r\n    } else if (orientation === \"Vertical\") {\r\n      // console.log(\"Vertical \", startX, startY, endX, endY);\r\n      const wallY = getRandomInteger(startY + 1, endY - 1);\r\n      const skipX = getRandomInteger(startX, endX);\r\n      for (let wallX = startX; wallX <= endX; ++wallX) {\r\n        if (wallX === skipX) continue;\r\n        const node = grid[wallX][wallY];\r\n        node.isWall = true;\r\n        visitedNodesInOrder.push(node);\r\n      }\r\n      recursiveDivisionUtil(\r\n        grid,\r\n        visitedNodesInOrder,\r\n        startX,\r\n        endX,\r\n        startY,\r\n        wallY - 1\r\n      ); //Left\r\n      recursiveDivisionUtil(\r\n        grid,\r\n        visitedNodesInOrder,\r\n        startX,\r\n        endX,\r\n        wallY + 1,\r\n        endY\r\n      ); //Right\r\n    }\r\n  }\r\n  \r\n  const getOrientation = (HEIGHT, WIDTH) => {\r\n    let orientation = null;\r\n    if (HEIGHT > WIDTH) {\r\n      orientation = \"Horizontal\";\r\n    } else if (WIDTH > HEIGHT) {\r\n      orientation = \"Vertical\";\r\n    } else {\r\n      const i = getRandomInteger(1, 2);\r\n      if (i === 1) orientation = \"Horizontal\";\r\n      else orientation = \"Vertical\";\r\n    }\r\n    return orientation;\r\n  };\r\n  \r\n  const getRandomInteger = (min, max) => {\r\n    max = max + 1;\r\n    return Math.floor(Math.random() * (max - min)) + min;\r\n  };\r\n  ","import React from \"react\";\r\nimport Node from \"./Node/Node\";\r\nimport { bfs, getNodesInShortestPathOrder } from \"../algorithms/bfs\";\r\nimport \"./PathfindingVisualizer.css\";\r\nimport { dfs } from \"../algorithms/dfs\";\r\nimport { djikstra } from \"../algorithms/djikstra\";\r\nimport { dfsMaze } from \"../MazeAlgorithms/dfsMaze\";\r\nimport { recursiveDivision } from \"../MazeAlgorithms/recursiveDivision\";\r\n\r\nvar HEIGHT = 20;\r\nvar WIDTH = 50;\r\nvar START_ROW = 10;\r\nvar START_COL = 15;\r\nvar FINISH_ROW = 5;\r\nvar FINISH_COL = 35;\r\nvar stopAnimating = false;\r\n//var pause = false;\r\n\r\nconst getRandomInteger = (min, max) => {\r\n  max = max + 1;\r\n  return Math.floor(Math.random() * (max - min)) + min;\r\n};\r\n\r\nexport default class PathfindingVisualizer extends React.Component {\r\n  constructor() {\r\n    super();\r\n    this.state = {\r\n      grid: [],\r\n      isMousePressed: false,\r\n      isPickStart: false,\r\n      isPickEnd: false,\r\n      isBfs: false,\r\n      isDfs: false,\r\n      isWeight: false,\r\n      isPlaceWeight: false,\r\n      isDjikstra: false,\r\n      isAnimating: false,\r\n      isDfsMaze: false,\r\n      recursiveDivision: false,\r\n      isMazeAnimating: false,\r\n    };\r\n  }\r\n\r\n  state1 = {\r\n    background: \"green\",\r\n  };\r\n  componentDidMount() {\r\n    const grid = getInitialGrid();\r\n    this.setState({ grid });\r\n  }\r\n\r\n  pickStart() {\r\n    this.setState({ isPickStart: true });\r\n  }\r\n\r\n  pickEnd() {\r\n    this.setState({ isPickEnd: true });\r\n  }\r\n\r\n  handleMouseDown(row, col) {\r\n    if (this.state.isAnimating === true || this.state.isMazeAnimating === true)\r\n      return;\r\n    if (row === START_ROW && col === START_COL) {\r\n      const newGrid = getNewGridWithStartToggled(this.state.grid, row, col);\r\n      this.setState({\r\n        isMousePressed: true,\r\n        isPickStart: true,\r\n      });\r\n      return;\r\n    }\r\n    if (row === FINISH_ROW && col === FINISH_COL) {\r\n      const newGrid = getNewGridWithEndToggled(this.state.grid, row, col);\r\n      this.setState({\r\n        isMousePressed: true,\r\n        isPickEnd: true,\r\n      });\r\n      return;\r\n    }\r\n    if (this.state.isPlaceWeight) {\r\n      const newGrid = getNewGridWithWeightToggled(this.state.grid, row, col);\r\n      this.setState({\r\n        grid: newGrid,\r\n        isMousePressed: true,\r\n      });\r\n      return;\r\n    }\r\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n    this.setState({\r\n      grid: newGrid,\r\n      isMousePressed: true,\r\n    });\r\n  }\r\n\r\n  handleMouseUp() {\r\n    if (this.state.isAnimating || this.state.isMazeAnimating) return;\r\n    if (this.state.isPickStart) {\r\n      this.setState({\r\n        isPickStart: false,\r\n      });\r\n    }\r\n    if (this.state.isPickEnd) {\r\n      this.setState({\r\n        isPickEnd: false,\r\n      });\r\n    }\r\n    this.setState({\r\n      isMousePressed: false,\r\n    });\r\n  }\r\n\r\n  handleMouseEnter(row, col) {\r\n    if (this.state.isPickStart) {\r\n      START_ROW = row;\r\n      START_COL = col;\r\n      // const newGrid = getNewGridWithStartToggled1(this.state.grid, row, col);\r\n      // this.setState({\r\n      //   grid: newGrid,\r\n      // });\r\n      return;\r\n    }\r\n    if (this.state.isPickEnd) {\r\n      FINISH_COL = col;\r\n      FINISH_ROW = row;\r\n      return;\r\n    }\r\n    if (!this.state.isMousePressed) return;\r\n    if (this.state.isPlaceWeight) {\r\n      const newGrid = getNewGridWithWeightToggled(this.state.grid, row, col);\r\n      this.setState({\r\n        grid: newGrid,\r\n      });\r\n      return;\r\n    }\r\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n    this.setState({\r\n      grid: newGrid,\r\n    });\r\n  }\r\n\r\n  handleWeight() {\r\n    this.setState({\r\n      isPlaceWeight: !this.state.isPlaceWeight,\r\n    });\r\n  }\r\n  refreshBoardForPathfinding(currGrid) {\r\n    // Defaults visited & distance of each node. Need this before\r\n    // running the pathfinding algorithms\r\n    const grid = currGrid.slice();\r\n    for (const row of grid) {\r\n      for (const node of row) {\r\n        node.distance = Infinity;\r\n        node.isVisited = false;\r\n      }\r\n    }\r\n    return grid;\r\n  }\r\n\r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    const firstNodeInShortestPath = nodesInShortestPathOrder[0];\r\n    if (\r\n      !(\r\n        firstNodeInShortestPath.row === START_ROW &&\r\n        firstNodeInShortestPath.col === START_COL\r\n      )\r\n    ) {\r\n      alert(\"No Shortest Path\");\r\n      return;\r\n    }\r\n    const node = nodesInShortestPathOrder[0];\r\n    document.getElementById(`node-${node.row}-${node.col}`).className =\r\n      \"node node-shortest-path node-start\";\r\n\r\n    let i = 1;\r\n    function animate() {\r\n      if (stopAnimating) {\r\n        //clearBoard();\r\n        return;\r\n      }\r\n      const node = nodesInShortestPathOrder[i];\r\n      if (i === nodesInShortestPathOrder.length - 1) {\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-shortest-path node-finish\";\r\n        return;\r\n      } else {\r\n        if (node.isWeight) {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-weight node-shortest-path\";\r\n        } else {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-shortest-path\";\r\n        }\r\n        // document.getElementById(`node-${node.row}-${node.col}`).className =\r\n        //   \"node \";\r\n      }\r\n      i++;\r\n\r\n      requestAnimationFrame(animate);\r\n    }\r\n    animate();\r\n  }\r\n\r\n  animateVisitedNodes(\r\n    visitedNodesInOrder,\r\n    nodesInShortestPathOrder,\r\n    startNode,\r\n    finishNode\r\n  ) {\r\n    let i = 1;\r\n    let animatingShortestPath = this.animateShortestPath;\r\n    //let enableExceptClearboard = this.enableExceptClearboard;\r\n    this.setState({\r\n      isAnimating: true,\r\n    });\r\n    function animate() {\r\n      if (stopAnimating) {\r\n        //enableExceptClearboard();\r\n        return;\r\n      }\r\n      if (i === visitedNodesInOrder.length - 1) {\r\n        console.log(\"animating shortest path\");\r\n        //animatingShortestPath(nodesInShortestPathOrder, enableExceptClearboard);\r\n        animatingShortestPath(nodesInShortestPathOrder);\r\n        //document.getElementById(\"clear\").disabled = false;\r\n        return;\r\n      }\r\n      const node = visitedNodesInOrder[i];\r\n      const { row, col } = node;\r\n      if (\r\n        !(row === START_ROW && col === START_COL) ||\r\n        (row === FINISH_ROW && col === FINISH_COL)\r\n      ) {\r\n        if (node.isWeight) {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-weight node-visited\";\r\n        } else {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-visited\";\r\n        }\r\n      }\r\n      i++;\r\n      requestAnimationFrame(animate);\r\n    }\r\n    animate();\r\n  }\r\n\r\n  visualizeBFS() {\r\n    if (this.state.isBfs || this.state.isDfs || this.state.isDjikstra) {\r\n      return;\r\n    } else {\r\n      stopAnimating = false;\r\n      this.setState({\r\n        isBfs: true,\r\n      });\r\n    }\r\n    let { grid } = this.state;\r\n    const startNode = grid[START_ROW][START_COL];\r\n    const finishNode = grid[FINISH_ROW][FINISH_COL];\r\n    //grid = this.refreshBoardForPathfinding(grid);\r\n    const visitedNodesInOrder = bfs(grid, startNode, finishNode);\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n    this.animateVisitedNodes(\r\n      visitedNodesInOrder,\r\n      nodesInShortestPathOrder,\r\n      startNode,\r\n      finishNode\r\n    );\r\n  }\r\n\r\n  visualizeDFS() {\r\n    if (this.state.isBfs || this.state.isDfs || this.state.isDjikstra) {\r\n      return;\r\n    }\r\n    // if (START_ROW == -1 || START_COL == -1) {\r\n    //   alert(\"start node isn't selected\");\r\n    //   return;\r\n    // }\r\n    // if (FINISH_NODE_ROW == -1 || FINISH_NODE_COL == -1) {\r\n    //   alert(\"end node isn't selected\");\r\n    // }\r\n    // document.getElementsByClassName(\"info\")[0].innerHTML =\r\n    //   \"Breadth First Search Algorithm is <strong>unweighted</strong> algorithm and <strong>guarentees</strong> shortest path\";\r\n    // this.disableExceptClearboard();\r\n    this.setState({\r\n      isDfs: true,\r\n    });\r\n    stopAnimating = false;\r\n    let { grid } = this.state;\r\n    const startNode = grid[START_ROW][START_COL];\r\n    const finishNode = grid[FINISH_ROW][FINISH_COL];\r\n    //grid = this.refreshBoardForPathfinding(grid);\r\n    const visitedNodesInOrder = dfs(grid, startNode, finishNode);\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n    this.animateVisitedNodes(\r\n      visitedNodesInOrder,\r\n      nodesInShortestPathOrder,\r\n      startNode,\r\n      finishNode\r\n    );\r\n  }\r\n\r\n  visualizeDJIKSTRA() {\r\n    if (this.state.isBfs || this.state.isDfs || this.state.isDjikstra) {\r\n      return;\r\n    } else {\r\n      stopAnimating = false;\r\n      this.setState({\r\n        isDjikstra: true,\r\n      });\r\n    }\r\n\r\n    let { grid } = this.state;\r\n    const startNode = grid[START_ROW][START_COL];\r\n    const finishNode = grid[FINISH_ROW][FINISH_COL];\r\n    grid = this.refreshBoardForPathfinding(grid);\r\n    const visitedNodesInOrder = djikstra(grid, startNode, finishNode);\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n    this.animateVisitedNodes(\r\n      visitedNodesInOrder,\r\n      nodesInShortestPathOrder,\r\n      startNode,\r\n      finishNode\r\n    );\r\n  }\r\n  clearBoard() {\r\n    START_ROW = 10;\r\n    START_COL = 15;\r\n    FINISH_ROW = 5;\r\n    FINISH_COL = 35;\r\n    stopAnimating = true;\r\n    const newGrid = getInitialGrid();\r\n    for (let row = 0; row < newGrid.length; ++row) {\r\n      for (let col = 0; col < newGrid[0].length; ++col) {\r\n        if (row === 10 && col === 15) {\r\n          document.getElementById(`node-${row}-${col}`).className =\r\n            \"node node-start\";\r\n          continue;\r\n        } else if (row === FINISH_ROW && col === FINISH_COL) {\r\n          document.getElementById(`node-${row}-${col}`).className =\r\n            \"node node-finish\";\r\n          continue;\r\n        } else {\r\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n        }\r\n      }\r\n    }\r\n    this.setState({\r\n      grid: newGrid,\r\n      isBfs: false,\r\n      isDfs: false,\r\n      isDjikstra: false,\r\n      isWall: false,\r\n      isWeight: false,\r\n      isPlaceWeight: false,\r\n      isMousePressed: false,\r\n      isAnimating: false,\r\n      isMazeAnimating: false,\r\n    });\r\n  }\r\n\r\n  refreshBoardForMaze(currGrid) {\r\n    let grid = currGrid.slice();\r\n    for (const row of grid) {\r\n      for (const node of row) {\r\n        node.isVisited = false;\r\n        node.isWall = false;\r\n      }\r\n    }\r\n    return grid;\r\n  }\r\n\r\n  visualizeDFSMaze() {\r\n    //21*51 board\r\n    stopAnimating = false;\r\n    let { grid } = this.state;\r\n    grid = this.refreshBoardForMaze(grid);\r\n    let start_x = getRandomInteger(0, HEIGHT);\r\n    let start_y = getRandomInteger(0, WIDTH);\r\n    while (start_x % 2 != 0) {\r\n      start_x = getRandomInteger(0, HEIGHT);\r\n    }\r\n    while (start_y % 2 != 0) {\r\n      start_y = getRandomInteger(0, WIDTH);\r\n    }\r\n    const visitedNodesInOrder = dfsMaze(grid, start_x, start_y);\r\n    this.animateMaze(visitedNodesInOrder);\r\n  }\r\n\r\n  visualizeRecursiveDivision() {\r\n    stopAnimating = false;\r\n    let { grid } = this.state;\r\n    grid = this.refreshBoardForMaze(grid);\r\n    const visitedNodesInOrder = recursiveDivision(grid);\r\n    this.animateMaze(visitedNodesInOrder);\r\n  }\r\n\r\n  animateMaze(visitedNodesInOrder) {\r\n    let i = 1;\r\n    //let enableExceptClearboard = this.enableExceptClearboard;\r\n\r\n    function animate() {\r\n      if (stopAnimating) {\r\n        //enableExceptClearboard();\r\n        return;\r\n      }\r\n      if (i === visitedNodesInOrder.length - 1) {\r\n        return;\r\n      }\r\n      const node = visitedNodesInOrder[i];\r\n      if (\r\n        node.row !== START_ROW &&\r\n        node.col !== START_COL &&\r\n        node.col !== FINISH_COL &&\r\n        node.row !== FINISH_ROW\r\n      )\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-wall\";\r\n      i++;\r\n      requestAnimationFrame(animate);\r\n    }\r\n    animate();\r\n  }\r\n\r\n  render() {\r\n    const { grid, isMousePressed } = this.state;\r\n    return (\r\n      <>\r\n        <nav\r\n          class=\"navbar navbar-expand-sm fixed-top navbar-dark bg-dark\"\r\n          id=\"myNavbar\"\r\n        >\r\n          <a class=\"navbar-brand\" href=\"#\" id=\"logo\">\r\n            Pathfinding Visualizer\r\n          </a>\r\n          <button\r\n            class=\"navbar-toggler\"\r\n            type=\"button\"\r\n            data-toggle=\"collapse\"\r\n            data-target=\"#navbarSupportedContent\"\r\n            aria-controls=\"navbarSupportedContent\"\r\n            aria-expanded=\"false\"\r\n            aria-label=\"Toggle navigation\"\r\n          >\r\n            <span class=\"navbar-toggler-icon\"></span>\r\n          </button>\r\n\r\n          <div class=\"collapse navbar-collapse\" id=\"navbarSupportedContent\">\r\n            <ul class=\"navbar-nav mr-auto\">\r\n              <li class=\"nav-item dropdown\" id=\"mazes\">\r\n                <a\r\n                  class=\"nav-link dropdown-toggle\"\r\n                  href=\"#\"\r\n                  id=\"navbarDropdown\"\r\n                  role=\"button\"\r\n                  data-toggle=\"dropdown\"\r\n                  aria-haspopup=\"true\"\r\n                  aria-expanded=\"false\"\r\n                >\r\n                  Mazes\r\n                </a>\r\n                <div class=\"dropdown-menu\" aria-labelledby=\"navbarDropdown\">\r\n                  <a\r\n                    class=\"dropdown-item\"\r\n                    href=\"#\"\r\n                    onClick={() => {\r\n                      this.state.isDfsMaze = true;\r\n                      this.visualizeDFSMaze();\r\n                    }}\r\n                  >\r\n                    Dfs Maze\r\n                  </a>\r\n                  <a\r\n                    class=\"dropdown-item\"\r\n                    href=\"#\"\r\n                    onClick={() => {\r\n                      this.state.recursiveDivision = true;\r\n                      this.visualizeRecursiveDivision();\r\n                    }}\r\n                  >\r\n                    Recursive Division\r\n                  </a>\r\n                  {/* <a class=\"dropdown-item\" href=\"#\">\r\n                    Recursive Division (Vertical Skew)\r\n                  </a>\r\n                  <a class=\"dropdown-item\" href=\"#\">\r\n                    Recursive Division (Horizontal Skew)\r\n                  </a>\r\n                  <a class=\"dropdown-item\" href=\"#\">\r\n                    Simple Spiral\r\n                  </a> */}\r\n                </div>\r\n              </li>\r\n              .\r\n            </ul>\r\n            <div className=\"weight\">\r\n              <button\r\n                type=\"button\"\r\n                className=\"btn btn-warning\"\r\n                onClick={() => {\r\n                  this.handleWeight();\r\n                }}\r\n              >\r\n                Weight\r\n              </button>\r\n            </div>\r\n            <div className=\"app\">\r\n              <button\r\n                type=\"button\"\r\n                class=\"btn btn-success\"\r\n                onClick={() => {\r\n                  this.visualizeBFS();\r\n                }}\r\n              >\r\n                Visualize BFS\r\n              </button>\r\n            </div>\r\n            <div className=\"app1\">\r\n              <button\r\n                type=\"button\"\r\n                class=\"btn btn-success\"\r\n                onClick={() => {\r\n                  this.visualizeDFS();\r\n                }}\r\n              >\r\n                Visualize DFS\r\n              </button>\r\n            </div>\r\n            <div className=\"app2\">\r\n              <button\r\n                type=\"button\"\r\n                class=\"btn btn-success\"\r\n                onClick={() => {\r\n                  this.visualizeDJIKSTRA();\r\n                }}\r\n              >\r\n                Visualize DJIKSTRA\r\n              </button>\r\n            </div>\r\n            <button\r\n              type=\"button\"\r\n              class=\"btn btn-danger\"\r\n              onClick={() => {\r\n                this.clearBoard();\r\n              }}\r\n            >\r\n              Clear\r\n            </button>\r\n          </div>\r\n        </nav>\r\n        <div className=\"row\" style={{ paddingTop: \"60px\" }}>\r\n          <div className=\"col-sm-2\">\r\n            <div className=\"app4\"></div>\r\n            <h3>Start </h3>\r\n          </div>\r\n          <div className=\"col-sm-2\">\r\n            <div className=\"app5\"></div>\r\n            <h3>End </h3>\r\n          </div>\r\n          <div className=\"col-sm-2\">\r\n            <div className=\"app6\"></div>\r\n            <h3>Visited </h3>\r\n          </div>\r\n          <div className=\"col-sm-2\">\r\n            <div className=\"app7\"></div>\r\n            <h3>Unvisited </h3>\r\n          </div>\r\n          <div className=\"col-sm-2\">\r\n            <div className=\"app8\"></div>\r\n            <h3>Shortest-Path </h3>\r\n          </div>\r\n          <div className=\"col-sm-2\">\r\n            <div className=\"app9\"></div>\r\n            <h3>Wall </h3>\r\n          </div>\r\n        </div>\r\n        <div className=\"grid main\">\r\n          {grid.map((row, rowIndex) => {\r\n            return (\r\n              <div key={rowIndex}>\r\n                {row.map((node, nodeIndex) => {\r\n                  const {\r\n                    row,\r\n                    col,\r\n                    isFinish,\r\n                    isStart,\r\n                    isWall,\r\n                    isWeight,\r\n                  } = node;\r\n                  return (\r\n                    <Node\r\n                      key={nodeIndex}\r\n                      col={col}\r\n                      isFinish={isFinish}\r\n                      isStart={isStart}\r\n                      isWall={isWall}\r\n                      isWeight={isWeight}\r\n                      isMousePressed={isMousePressed}\r\n                      onMouseDown={(row, col) => {\r\n                        this.handleMouseDown(row, col);\r\n                      }}\r\n                      onMouseEnter={(row, col) => {\r\n                        this.handleMouseEnter(row, col);\r\n                      }}\r\n                      onMouseUp={() => {\r\n                        this.handleMouseUp();\r\n                      }}\r\n                      row={row}\r\n                    ></Node>\r\n                  );\r\n                })}\r\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nconst getInitialGrid = () => {\r\n  const grid = [];\r\n  for (let row = 0; row <= HEIGHT; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col <= WIDTH; col++) {\r\n      currentRow.push(createNode(col, row));\r\n    }\r\n    grid.push(currentRow);\r\n  }\r\n  return grid;\r\n};\r\n\r\nconst createNode = (col, row) => {\r\n  return {\r\n    col,\r\n    row,\r\n    isStart: row === 10 && col === 15,\r\n    isFinish: row === 5 && col === 35,\r\n    isVisited: false,\r\n    isWall: false,\r\n    isWeight: false,\r\n    previousNode: null,\r\n  };\r\n};\r\n\r\nconst getNewGridWithWallToggled = (grid, row, col) => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  // This node has isWall=True which makes its className='node-wall' whose color is black as specified in the styling\r\n  const newNode = {\r\n    ...node,\r\n    isWall: !node.isWall,\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n};\r\n\r\nconst getNewGridWithWeightToggled = (grid, row, col) => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  // This node has isWall=True which makes its className='node-wall' whose color is black as specified in the styling\r\n  const newNode = {\r\n    ...node,\r\n    isWeight: !node.isWeight,\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n};\r\n\r\nconst getNewGridWithStartToggled = (grid, row, col) => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  // This node has isStart=True which makes its className='node-start' whose color is specified in the styling\r\n  const newNode = {\r\n    ...node,\r\n    isStart: !node.isStart,\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n};\r\n\r\nconst getNewGridWithEndToggled = (grid, row, col) => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  // This node has isEnd=True which makes its className='node-end' whose color is specified in the styling\r\n  const newNode = {\r\n    ...node,\r\n    isFinish: !node.isFinish,\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n};\r\n","import React from \"react\";\nimport logo from \"./logo.svg\";\nimport \"./App.css\";\nimport PathfindingVisualizer from \"./PathfindingVisualizer/PathfindingVisualizer\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer></PathfindingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}